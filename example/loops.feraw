cc {
    function(feraw_dup)
    {
        BruterMeta value = bruter_pop_meta(stack);
        bruter_push_meta(stack, value); // Push the value back to the stack
        bruter_push_meta(stack, value); // Duplicate it
    }

    function(feraw_shift)
    {
        BruterList* list = bruter_pop_pointer(stack);
        BruterMeta value = bruter_shift_meta(list);
        free(value.key); // Free the key if it exists
        bruter_push_meta(stack, value); // Push the shifted value back to the stack
    }

    function(feraw_add)
    {
        BruterMeta a = bruter_pop_meta(stack);
        BruterMeta b = bruter_pop_meta(stack);
        switch (a.type)
        {
            case BRUTER_TYPE_FLOAT:
                switch (b.type)
                {
                    case BRUTER_TYPE_FLOAT:
                        bruter_push_float(stack, a.value.f + b.value.f, NULL, BRUTER_TYPE_FLOAT);
                        break;
                    default:
                        bruter_push_float(stack, a.value.f + b.value.i, NULL, BRUTER_TYPE_FLOAT);
                        break;
                }
                break;
            default:
                switch (b.type)
                {
                    case BRUTER_TYPE_FLOAT:
                        bruter_push_float(stack, a.value.i + b.value.f, NULL, BRUTER_TYPE_FLOAT);
                        break;
                    default:
                        bruter_push_int(stack, a.value.i + b.value.i, NULL, BRUTER_TYPE_ANY);
                        break;
                }
                break;
        }
    }

    function(feraw_less)
    {
        BruterInt a = bruter_pop_int(stack);
        BruterInt b = bruter_pop_int(stack);
        bruter_push_int(stack, a < b ? 1 : 0, NULL, BRUTER_TYPE_ANY);
    }

    function (feraw_print)
    {
        BruterMeta value = bruter_pop_meta(stack);
        switch (value.type)
        {
            case BRUTER_TYPE_FLOAT:
                printf("%f", value.value.f);
                break;
            case BRUTER_TYPE_BUFFER:
                printf("%s", (char*)value.value.p);
                break;
            case BRUTER_TYPE_LIST:
                for (BruterInt i = 0; i < ((BruterList*)value.value.p)->size; i++)
                {
                    BruterMeta item = bruter_get_meta((BruterList*)value.value.p, i);
                    switch (item.type)
                    {
                        case BRUTER_TYPE_FLOAT:
                            printf("%f ", item.value.f);
                            break;
                        case BRUTER_TYPE_BUFFER:
                            printf("%s ", (char*)item.value.p);
                            break;
                        case BRUTER_TYPE_LIST:
                            printf("[List] ");
                            break;
                        default:
                            printf("%ld ", item.value.i);
                            break;
                    }
                }
                break;
            default:
                printf("%ld", value.value.i);
                break;
        }
    }

    function(feraw_println)
    {
        feraw_print(stack);
        printf("\n");
    }
};
// this example, unlike the hello-world example this is probably not so familiar to most people
// the good part of having no rules at all is that no code is arbitrary, even when it is
// in this case everything is expected and predictable, so i would not consider it arbitrary

// lets put the index into the stack
// seems a loose call, but it will stay on the stack until something consumes it or manually removed
// we will never let the index go out of stack
#dup(0);

// the # is the static operator, it put the value directly on the code as literal
// using static variables are way faster than search for a variable

// & is the stack itself
// if the index is less than 100000, we go back to the start label, 
// we manipulate the stack directly(inside itself) bcause we want to reorganize the stack to the ifgo call
while(#less(#shift(stack), 100000))
{
    // print is receive no arguments, thus it wont push any args to the stack
    // but we already have 2 values on the stack we pushed before, so print will consume one of them
    #println();
    // we add 1 to whatever is on the stack, which is the index
    // and then we duplicate it
    #dup(#add(1));
};

// end label is where i usually put the free's and such
// we dont have any here because we didnt allocate any memory(or used any strings)
// even is those cases i find interesting to have the end label, like to just interrupt(this can also be done safely by going out of bounds)
end: