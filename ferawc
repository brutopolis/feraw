#!/bin/bash

ORIGIN=$(pwd)
SUDO=$(command -v sudo >/dev/null && echo "sudo" || echo "")
CC=${CC:-"gcc -O3"}

MODE="embed"
SRC_FILE=""
LIB_HEADERS=""
LIB_INITS=""

# Processa argumentos
for arg in "$@"; do
    case "$arg" in
        --interpreter)
            MODE="interpreter"
            ;;
        --transpile)
            MODE="transpile"
            ;;
        -*)
            echo "[=°~°=]: unknown option: $arg"
            exit 1
            ;;
        *.c)
            BASE_NAME=$(basename "$arg" .c)
            LIB_HEADERS+=$'\n'"// Begin $arg"$'\n'
            LIB_HEADERS+="$(cat "$arg")"
            LIB_HEADERS+=$'\n'"// End $arg"$'\n'
            LIB_INITS+="    init_$BASE_NAME(context);"$'\n'
            ;;
        *)
            if [[ -z "$SRC_FILE" ]]; then
                SRC_FILE="$arg"
            else
                echo "[=°~°=]: multiple source files specified: $SRC_FILE and $arg"
                exit 1
            fi
            ;;
    esac
done

# Modo transpile
if [[ "$MODE" == "transpile" ]]; then
    if ! command -v node >/dev/null; then
        echo "[=°~°=]: Node.js not found"
        exit 1
    fi
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    FERAW_JS_PATH="$SCRIPT_DIR/feraw.js"

    if [[ -n "$FERAW_JS_FILE" ]]; then
        NODE_SCRIPT="$FERAW_JS_FILE"
    elif [[ -f "$FERAW_JS_PATH" ]]; then
        NODE_SCRIPT="$(cat "$FERAW_JS_PATH")"
    else
        echo "[=°~°=]: 'feraw.js' not found and FERAW_JS_FILE not set"
        exit 1
    fi

    node -e "$NODE_SCRIPT; process.stdout.write(feraw_compile(process.argv[1]));" "$(cat "$SRC_FILE")"

    exit 0
fi

ESCAPED_CONTENT=$(sed 's/\\/\\\\/g; s/"/\\"/g; s/^/"/; s/$/\\n"/' "$SRC_FILE")

# Geração de código final
if [[ "$MODE" == "embed" ]]; then
    cat <<EOF
#include "bruter.h"

$LIB_HEADERS

int main(int argc, char *argv[])
{
    BruterList *context = bruter_new(8, true, true);
$LIB_INITS
    const char *embedded_code =
$ESCAPED_CONTENT
    ;

    BruterList *result = bruter_parse(context, embedded_code);
    bruter_free(result);
    bruter_free(context);
    return EXIT_SUCCESS;
}
EOF

else  # interpreter
    cat <<EOF
#include "bruter.h"

$LIB_HEADERS

int main(int argc, char *argv[])
{
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <source_file>\n", argv[0]);
        return EXIT_FAILURE;
    }

    BruterList *context = bruter_new(8, true, true);
$LIB_INITS
    const char *filename = argv[1];
    FILE *file = fopen(filename, "r");
    if (!file) {
        fprintf(stderr, "ERROR: Could not open file '%s'\n", filename);
        return EXIT_FAILURE;
    }

    fseek(file, 0, SEEK_END);
    long length = ftell(file);
    fseek(file, 0, SEEK_SET);
    char *input_str = malloc(length + 1);
    if (!input_str) {
        fprintf(stderr, "ERROR: Could not allocate memory\n");
        fclose(file);
        return EXIT_FAILURE;
    }

    fread(input_str, 1, length, file);
    input_str[length] = '\\0';
    fclose(file);

    BruterList *result = bruter_parse(context, input_str);
    bruter_free(result);
    free(input_str);
    bruter_free(context);
    return EXIT_SUCCESS;
}
EOF

fi

exit 0
