
cc {
    include("../lib/std.c");
    include("../lib/mem.c");
    include("raylib.c");
};

RAYLIB_VERSION = "5.5";

PI = 3.14159265358979323846;
DEG2RAD = div(PI, 180.0);
RAD2DEG = div(180.0, PI);


// Some Basic Colors
// NOTE: Custom raylib color palette for amazing visuals on WHITE background
LIGHTGRAY  = 0b11001000110010001100100011111111; // 200, 200, 200, 255
GRAY       = 0b10000010100000101000001011111111; // 130, 130, 130, 255
DARKGRAY   = 0b01010000010100000101000011111111; // 80, 80, 80, 255
YELLOW     = 0b11111101111110010000000011111111; // 253, 249, 0, 255
GOLD       = 0b11111111110010110000000011111111; // 255, 203, 0, 255
ORANGE     = 0b11111111101000010000000011111111; // 255, 161, 0, 255
PINK       = 0b11111111011011011100001011111111; // 255, 109, 194, 255
RED        = 0b11100110001010010011011111111111; // 230, 41, 55, 255
MAROON     = 0b10111110001000010011011111111111; // 190, 33, 55, 255
GREEN      = 0b00000000111001000011000011111111; // 0, 228, 48, 255
LIME       = 0b00000000100111100010111111111111; // 0, 158, 47, 255
DARKGREEN  = 0b00000000011101010010110011111111; // 0, 117, 44, 255
SKYBLUE    = 0b01100110101111111111111111111111; // 102, 191, 255, 255
BLUE       = 0b00000000011110011111000111111111; // 0, 121, 241, 255
DARKBLUE   = 0b00000000010100101010110011111111; // 0, 82, 172, 255
PURPLE     = 0b11001000111100011111111111111111; // 200, 122, 255, 255
VIOLET     = 0b10000111001111001011111011111111; // 135, 60, 190, 255
DARKPURPLE = 0b01110000000111110111111011111111; // 112, 31, 126, 255
BEIGE      = 0b01110000101100001000001111111111; // 211, 176, 131, 255
BROWN      = 0b01111111011010100100111111111111; // 127, 106, 79, 255
DARKBROWN  = 0b01001100001111110010111111111111; // 76, 63, 47, 255
WHITE      = 0b11111111111111111111111111111111; // 255, 255, 255, 255
BLACK      = 0b00000000000000000000000011111111; // 0, 0, 0, 255
BLANK      = 0b00000000000000000000000000000000; // 0, 0, 0, 0
MAGENTA    = 0b11111111000000001111111111111111; // 255, 0, 255, 255
RAYWHITE   = 0b11110101111101011111010111111111; // 245, 245, 245, 255

Vector2 = macro{
    tempvec2 = list(0);
    tempvec2.x = $0;
    tempvec2.y = $1;
    remove(context, find(context, "tempvec2"));
};

// fast way of doing the same thing, but much more verbose and much less readable
Vector3 = macro{
    list(0);
    dup();
    set(remove(stack, -3), "x", $0);
    dup();
    set(remove(stack, -3), "y", $1);
    dup();
    set(remove(stack, -3), "z", $2);
};

Vector4 = macro{
    temp_vector = list(0);
    temp_vector.x = $0;
    temp_vector.y = $1;
    temp_vector.z = $2;
    temp_vector.w = $3;
    remove(context, find(context, "temp_vector"));
};

// same as Vector4 but we cannot create aliases for macros 
Quaternion = macro{
    Vector4($0, $1, $2, $3);
};

Matrix = macro{
    temp_matrix = list(0);
    temp_matrix.m0 = $0; // m0
    temp_matrix.m4 = $1; // m4
    temp_matrix.m8 = $2; // m8
    temp_matrix.m12 = $3; // m12
    temp_matrix.m1 = $4; // m1
    temp_matrix.m5 = $5; // m5
    temp_matrix.m9 = $6; // m9
    temp_matrix.m13 = $7; // m13
    temp_matrix.m2 = $8; // m2
    temp_matrix.m6 = $9; // m6
    temp_matrix.m10 = $10; // m10
    temp_matrix.m14 = $11; // m14
    temp_matrix.m3 = $12; // m3
    temp_matrix.m7 = $13; // m7
    temp_matrix.m11 = $14; // m11
    temp_matrix.m15 = $15; // m15

    // the remove will push the matrix to the stack
    remove(context, find(context, "temp_matrix"));
};

// in feraw always prefer using color directly as hex
// but here it is, its part of the API
Color = macro{
    temp_color = 0;
    memset(temp_color, 0, $0); // r
    memset(temp_color, 1, $1); // g
    memset(temp_color, 2, $2); // b
    memset(temp_color, 3, $3); // a
    remove(context, find(context, "temp_color"));
}

Rectangle = macro{
    temp_rectangle = list(0);
    temp_rectangle.x = $0;
    temp_rectangle.y = $1;
    temp_rectangle.width = $2;
    temp_rectangle.height = $3;
    remove(context, find(context, "temp_rectangle"));
};

Image = macro{
    temp_image = list(0);
    temp_image.data = $0;
    temp_image.width = $1;
    temp_image.height = $2;
    temp_image.mipmaps = $3;
    temp_image.format = $4;
    remove(context, find(context, "temp_image"));
};

Texture = macro{
    temp_texture = list(0);
    temp_texture.id = $0;
    temp_texture.width = $1;
    temp_texture.height = $2;
    temp_texture.mipmaps = $3;
    temp_texture.format = $4;
    remove(context, find(context, "temp_texture"));
};

Texture2D = macro{
    Texture($0, $1, $2, $3, $4);
};

TextureCubeMap = macro{
    Texture($0, $1, $2, $3, $4);
};

RenderTexture = macro{
    temp_render_texture = list(0);
    temp_render_texture.id = $0;
    temp_render_texture.texture = $1;
    temp_render_texture.depth = $2;
    remove(context, find(context, "temp_render_texture"));
};

RenderTexture2D = macro{
    RenderTexture($0, $1, $2);
};

NPatchInfo = macro{
    temp_npatch_info = list(0);
    temp_npatch_info.source = $0;
    temp_npatch_info.left = $1;
    temp_npatch_info.top = $2;
    temp_npatch_info.right = $3;
    temp_npatch_info.bottom = $4;
    temp_npatch_info.layout = $5; // NPatchLayout
    remove(context, find(context, "temp_npatch_info"));
};

GlyphInfo = macro{
    temp_glyph_info = list(0);
    temp_glyph_info.value = $0; // codepoint
    temp_glyph_info.offsetX = $1;
    temp_glyph_info.offsetY = $2;
    temp_glyph_info.advanceX = $3;
    temp_glyph_info.image = $4; // Image
    remove(context, find(context, "temp_glyph_info"));
};

Font = macro{
    temp_font = list(0);
    temp_font.baseSize = $0;
    temp_font.glyphCount = $1;
    temp_font.glyphPadding = $2;
    temp_font.texture = $3;
    temp_font.recs = $4;
    temp_font.glyphs = $5;
    remove(context, find(context, "temp_font"));
};

Camera3D = macro{
    temp_camera3d = list(0);
    temp_camera3d.position = $0;
    temp_camera3d.target = $1;
    temp_camera3d.up = $2;
    temp_camera3d.fovy = $3;
    temp_camera3d.projection = $4;
    remove(context, find(context, "temp_camera3d"));
};

Camera = macro{
    Camera3D($0, $1, $2, $3, $4);
};

Camera2D = macro{
    temp_camera2d = list(0);
    temp_camera2d.offset = $0;
    temp_camera2d.target = $1;
    temp_camera2d.rotation = $2;
    temp_camera2d.zoom = $3;
    remove(context, find(context, "temp_camera2d"));
};

Mesh = macro{
    temp_mesh = list(0);
    temp_mesh.vertexCount = $0; // Number of vertices stored in arrays
    temp_mesh.triangleCount = $1; // Number of triangles stored (indexed or not)
    temp_mesh.vertices = $2; // Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
    temp_mesh.texcoords = $3; // Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
    temp_mesh.texcoords2 = $4; // Vertex texture second coordinates (UV - 2 components per vertex) (shader-location = 5)
    temp_mesh.normals = $5; // Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)
    temp_mesh.tangents = $6; // Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)
    temp_mesh.colors = $7; // Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
    temp_mesh.indices = $8; // Vertex indices (in case vertex data comes indexed)
    temp_mesh.animVertices = $9; // Animated vertex positions (after bones transformations)
    temp_mesh.animNormals = $10; // Animated normals (after bones transformations)
    temp_mesh.boneIds = $11; // Vertex bone ids, max 255 bone ids, up to 4 bones influence by vertex (skinning) (shader-location = 6)
    temp_mesh.boneWeights = $12; // Vertex bone weight, up to 4 bones influence by vertex (skinning) (shader-location = 7)
    temp_mesh.boneMatrices = $13; // Bones animated transformation matrices
    temp_mesh.boneCount = $14; // Number of bones
    temp_mesh.vaoId = $15; // OpenGL Vertex Array Object id
    temp_mesh.vboId = $16; // OpenGL Vertex Buffer Objects id (default vertex data)
    remove(context, find(context, "temp_mesh"));
};

Shader = macro{
    temp_shader = list(0);
    temp_shader.id = $0; // Shader program id
    temp_shader.locs = $1; // Shader locations array (max 32 locations)
    remove(context, find(context, "temp_shader"));
};

MaterialMap = macro{
    temp_material_map = list(0);
    temp_material_map.texture = $0; // Material map texture
    temp_material_map.color = $1; // Material map color
    temp_material_map.value = $2; // Material map value (depends on map type)
    remove(context, find(context, "temp_material_map"));
};

Material = macro{
    temp_material = list(0);
    temp_material.shader = $0; // Material shader
    temp_material.maps = $1; // Material maps array (max 8 maps)
    temp_material.params = $2; // Material generic parameters (if required)
    remove(context, find(context, "temp_material"));
};

Transform = macro{
    temp_transform = list(0);
    temp_transform.translation = $0; // Translation vector
    temp_transform.rotation = $1; // Quaternion rotation
    temp_transform.scale = $2; // Scale vector
    remove(context, find(context, "temp_transform"));
};

BoneInfo = macro{
    temp_bone_info = list(0);
    temp_bone_info.name = $0; // Bone name
    temp_bone_info.parent = $1; // Parent bone index
    temp_bone_info.transform = $2; // Local transform matrix
    remove(context, find(context, "temp_bone_info"));
};

Model = macro{
    temp_model = list(0);
    temp_model.transform = $0; // Local transform matrix
    temp_model.meshCount = $1; // Number of meshes
    temp_model.materialCount = $2; // Number of materials
    temp_model.meshes = $3; // Meshes array
    temp_model.materials = $4; // Materials array
    temp_model.meshMaterial = $5; // Mesh material number
    temp_model.boneCount = $6; // Number of bones
    temp_model.bones = $7; // Bones information (skeleton)
    temp_model.bindPose = $8; // Bones base transformation (pose)
    remove(context, find(context, "temp_model"));
};

ModelAnimation = macro{
    temp_model_animation = list(0);
    temp_model_animation.boneCount = $0; // Number of bones
    temp_model_animation.frameCount = $1; // Number of animation frames
    temp_model_animation.bones = $2; // Bones information (skeleton)
    temp_model_animation.framePoses = $3; // Poses array by frame
    temp_model_animation.name = $4; // Animation name
    remove(context, find(context, "temp_model_animation"));
};

Ray = macro{
    temp_ray = list(0);
    temp_ray.position = $0; // Ray position (origin)
    temp_ray.direction = $1; // Ray direction
    remove(context, find(context, "temp_ray"));
};

RayCollision = macro{
    temp_ray_collision = list(0);
    temp_ray_collision.hit = $0; // Did the ray hit something?
    temp_ray_collision.distance = $1; // Distance to the hit point
    temp_ray_collision.point = $2; // Point of the hit
    temp_ray_collision.normal = $3; // Normal of the hit
    temp_ray_collision.object = $4; // Object hit (mesh, model, etc.)
    remove(context, find(context, "temp_ray_collision"));
};

BoundingBox = macro{
    temp_bounding_box = list(0);
    temp_bounding_box.min = $0; // Minimum vertex of the box
    temp_bounding_box.max = $1; // Maximum vertex of the box
    remove(context, find(context, "temp_bounding_box"));
};

Wave = macro{
    temp_wave = list(0);
    temp_wave.frameCount = $0; // Number of audio frames (samples)
    temp_wave.sampleRate = $1; // Frequency (samples per second)
    temp_wave.sampleSize = $2; // Number of channels (1-mono, 2-stereo)
    temp_wave.channels = $3; // Number of channels (1-mono, 2-stereo)
    temp_wave.data = $4; // Buffer data pointer
    remove(context, find(context, "temp_wave"));
};

/* opaque structs that are part of raudio module
    rAudioBuffer = ?
    rAudioStream = ? 
*/

// i honestly dont know if this works without the above declarations
// might be tested later
AudioStream = macro{
    temp_audio_stream = list(0);
    temp_audio_stream.buffer = $0; // Audio buffer pointer
    temp_audio_stream.processor = $1; // Audio processor pointer
    temp_audio_stream.sampleRate = $2; // Sample rate (frequency)
    temp_audio_stream.sampleSize = $3; // Sample size (in bytes)
    temp_audio_stream.channels = $4; // Number of channels (1-mono, 2-stereo)
    remove(context, find(context, "temp_audio_stream"));
};

Sound = macro{
    temp_sound = list(0);
    temp_sound.stream = $0; // Audio stream
    temp_sound.frameCount = $1; // Number of audio frames (samples)
    remove(context, find(context, "temp_sound"));
};

Music = macro{
    temp_music = list(0);
    temp_music.stream = $0; // Audio stream
    temp_music.frameCount = $1; // Number of audio frames (samples)
    temp_music.looping = $2; // Music looping enabled
    temp_music.ctxType = $3; // Music context type (depends on backend)
    temp_music.ctxData = $4; // Music context data (depends on backend)
    remove(context, find(context, "temp_music"));
};

VrDeviceInfo = macro{
    temp_vr_device_info = list(0);
    temp_vr_device_info.hResolution = $0; // Horizontal resolution in pixels
    temp_vr_device_info.vResolution = $1; // Vertical resolution in pixels
    temp_vr_device_info.hScreenSize = $2; // Horizontal size in meters
    temp_vr_device_info.vScreenSize = $3; // Vertical size in meters
    temp_vr_device_info.vScreenCenter = $4; // Screen center in meters
    temp_vr_device_info.eyeToScreenDistance = $5; // Distance between eye and display in meters
    temp_vr_device_info.lensSeparationDistance = $6; // Lens separation distance in meters
    temp_vr_device_info.interpupillaryDistance = $7; // IPD (distance between pupils) in meters
    temp_vr_device_info.lensesDistortionValues = $8; // Lenses distortion values (k1, k2, k3, k4)
    temp_vr_device_info.chromaticAberrationValues = $9; // Chromatic aberration values (chromaShiftX, chromaShiftY)
    remove(context, find(context, "temp_vr_device_info"));
};

VrStereoConfig = macro {
    temp_vr_stereo_config = list(0);
    temp_vr_stereo_config.projection = $0; // Projection matrix for stereo rendering
    temp_vr_stereo_config.viewOffset = $1; // View offset for stereo rendering
    temp_vr_stereo_config.leftLensCenter = $2; // Left lens center in pixels
    temp_vr_stereo_config.rightLensCenter = $3; // Right lens center in pixels
    temp_vr_stereo_config.leftScreenCenter = $4; // Left screen center in pixels
    temp_vr_stereo_config.rightScreenCenter = $5; // Right screen center in pixels
    temp_vr_stereo_config.scale = $6; // Scale factor for stereo rendering
    temp_vr_stereo_config.scaleIn = $7; // Scale factor for stereo rendering (inner)
    remove(context, find(context, "temp_vr_stereo_config"));
};

FilePathList = macro{
    temp_file_path_list = list(0);
    temp_file_path_list.capacity = $0; // Maximum number of file paths
    temp_file_path_list.count = $1; // Current number of file paths
    temp_file_path_list.paths = $2; // Array of file paths
    remove(context, find(context, "temp_file_path_list"));
};

AutomationEvent = macro{
    temp_automation_event = list(0);
    temp_automation_event.type = $0; // Event type (e.g., note on, note off, control change)
    temp_automation_event.channel = $1; // MIDI channel (0-15)
    temp_automation_event.params = $2; // list of parameters(although it is a list, it will only consider the first 4 elements)
    remove(context, find(context, "temp_automation_event"));
};

AutomationEventList = macro{
    temp_automation_event_list = list(0);
    temp_automation_event_list.capacity = $0; // Maximum number of events
    temp_automation_event_list.count = $1; // Current number of events
    temp_automation_event_list.events = $2; // Array of events
    remove(context, find(context, "temp_automation_event_list"));
};

// System/Window config flags
// NOTE: Every bit registers one state (use it with bit masks)
// By default all flags are set to 0
FLAG_VSYNC_HINT               = 0x00000040;   // Set to try enabling V-Sync on GPU
FLAG_FULLSCREEN_MODE          = 0x00000002;   // Set to run program in fullscreen
FLAG_WINDOW_RESIZABLE         = 0x00000004;   // Set to allow resizable window
FLAG_WINDOW_UNDECORATED       = 0x00000008;   // Set to disable window decoration (frame and buttons)
FLAG_WINDOW_HIDDEN            = 0x00000080;   // Set to hide window
FLAG_WINDOW_MINIMIZED         = 0x00000200;   // Set to minimize window (iconify)
FLAG_WINDOW_MAXIMIZED         = 0x00000400;   // Set to maximize window (expanded to monitor)
FLAG_WINDOW_UNFOCUSED         = 0x00000800;   // Set to window non focused
FLAG_WINDOW_TOPMOST           = 0x00001000;   // Set to window always on top
FLAG_WINDOW_ALWAYS_RUN        = 0x00000100;   // Set to allow windows running while minimized
FLAG_WINDOW_TRANSPARENT       = 0x00000010;   // Set to allow transparent framebuffer
FLAG_WINDOW_HIGHDPI           = 0x00002000;   // Set to support HighDPI
FLAG_WINDOW_MOUSE_PASSTHROUGH = 0x00004000;   // Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED
FLAG_BORDERLESS_WINDOWED_MODE = 0x00008000;   // Set to run program in borderless windowed mode
FLAG_MSAA_4X_HINT             = 0x00000020;   // Set to try enabling MSAA 4X
FLAG_INTERLACED_HINT          = 0x00010000;   // Set to try enabling interlaced video format (for V3D)


// Trace log level
// NOTE: Organized by priority level
LOG_ALL = 0;            // Display all logs
LOG_TRACE = 1;          // Trace logging, intended for internal use only
LOG_DEBUG = 2;          // Debug logging, used for internal debugging, it should be disabled on release builds
LOG_INFO = 3;           // Info logging, used for program execution info
LOG_WARNING = 4;        // Warning logging, used on recoverable failures
LOG_ERROR = 5;          // Error logging, used on unrecoverable failures
LOG_FATAL = 6;          // Fatal logging, used to abort program: exit(EXIT_FAILURE)
LOG_NONE = 7;           // Disable logging


// Keyboard keys (US keyboard layout)
// NOTE: Use GetKeyPressed() to allow redefining
// required keys for alternative layouts
KEY_NULL            = 0;        // Key: NULL, used for no key pressed
// Alphanumeric keys
KEY_APOSTROPHE      = 39;       // Key: '
KEY_COMMA           = 44;       // Key: ,
KEY_MINUS           = 45;       // Key: -
KEY_PERIOD          = 46;       // Key: .
KEY_SLASH           = 47;       // Key: /
KEY_ZERO            = 48;       // Key: 0
KEY_ONE             = 49;       // Key: 1
KEY_TWO             = 50;       // Key: 2
KEY_THREE           = 51;       // Key: 3
KEY_FOUR            = 52;       // Key: 4
KEY_FIVE            = 53;       // Key: 5
KEY_SIX             = 54;       // Key: 6
KEY_SEVEN           = 55;       // Key: 7
KEY_EIGHT           = 56;       // Key: 8
KEY_NINE            = 57;       // Key: 9
KEY_SEMICOLON       = 59;       // Key: ;
KEY_EQUAL           = 61;       // Key: =
KEY_A               = 65;       // Key: A | a
KEY_B               = 66;       // Key: B | b
KEY_C               = 67;       // Key: C | c
KEY_D               = 68;       // Key: D | d
KEY_E               = 69;       // Key: E | e
KEY_F               = 70;       // Key: F | f
KEY_G               = 71;       // Key: G | g
KEY_H               = 72;       // Key: H | h
KEY_I               = 73;       // Key: I | i
KEY_J               = 74;       // Key: J | j
KEY_K               = 75;       // Key: K | k
KEY_L               = 76;       // Key: L | l
KEY_M               = 77;       // Key: M | m
KEY_N               = 78;       // Key: N | n
KEY_O               = 79;       // Key: O | o
KEY_P               = 80;       // Key: P | p
KEY_Q               = 81;       // Key: Q | q
KEY_R               = 82;       // Key: R | r
KEY_S               = 83;       // Key: S | s
KEY_T               = 84;       // Key: T | t
KEY_U               = 85;       // Key: U | u
KEY_V               = 86;       // Key: V | v
KEY_W               = 87;       // Key: W | w
KEY_X               = 88;       // Key: X | x
KEY_Y               = 89;       // Key: Y | y
KEY_Z               = 90;       // Key: Z | z
KEY_LEFT_BRACKET    = 91;       // Key: [
KEY_BACKSLASH       = 92;       // Key: '\'
KEY_RIGHT_BRACKET   = 93;       // Key: ]
KEY_GRAVE           = 96;       // Key: `
// Function keys
KEY_SPACE           = 32;       // Key: Space
KEY_ESCAPE          = 256;      // Key: Esc
KEY_ENTER           = 257;      // Key: Enter
KEY_TAB             = 258;      // Key: Tab
KEY_BACKSPACE       = 259;      // Key: Backspace
KEY_INSERT          = 260;      // Key: Ins
KEY_DELETE          = 261;      // Key: Del
KEY_RIGHT           = 262;      // Key: Cursor right
KEY_LEFT            = 263;      // Key: Cursor left
KEY_DOWN            = 264;      // Key: Cursor down
KEY_UP              = 265;      // Key: Cursor up
KEY_PAGE_UP         = 266;      // Key: Page up
KEY_PAGE_DOWN       = 267;      // Key: Page down
KEY_HOME            = 268;      // Key: Home
KEY_END             = 269;      // Key: End
KEY_CAPS_LOCK       = 280;      // Key: Caps lock
KEY_SCROLL_LOCK     = 281;      // Key: Scroll down
KEY_NUM_LOCK        = 282;      // Key: Num lock
KEY_PRINT_SCREEN    = 283;      // Key: Print screen
KEY_PAUSE           = 284;      // Key: Pause
KEY_F1              = 290;      // Key: F1
KEY_F2              = 291;      // Key: F2
KEY_F3              = 292;      // Key: F3
KEY_F4              = 293;      // Key: F4
KEY_F5              = 294;      // Key: F5
KEY_F6              = 295;      // Key: F6
KEY_F7              = 296;      // Key: F7
KEY_F8              = 297;      // Key: F8
KEY_F9              = 298;      // Key: F9
KEY_F10             = 299;      // Key: F10
KEY_F11             = 300;      // Key: F11
KEY_F12             = 301;      // Key: F12
KEY_LEFT_SHIFT      = 340;      // Key: Shift left
KEY_LEFT_CONTROL    = 341;      // Key: Control left
KEY_LEFT_ALT        = 342;      // Key: Alt left
KEY_LEFT_SUPER      = 343;      // Key: Super left
KEY_RIGHT_SHIFT     = 344;      // Key: Shift right
KEY_RIGHT_CONTROL   = 345;      // Key: Control right
KEY_RIGHT_ALT       = 346;      // Key: Alt right
KEY_RIGHT_SUPER     = 347;      // Key: Super right
KEY_KB_MENU         = 348;      // Key: KB menu
// Keypad keys
KEY_KP_0            = 320;      // Key: Keypad 0
KEY_KP_1            = 321;      // Key: Keypad 1
KEY_KP_2            = 322;      // Key: Keypad 2
KEY_KP_3            = 323;      // Key: Keypad 3
KEY_KP_4            = 324;      // Key: Keypad 4
KEY_KP_5            = 325;      // Key: Keypad 5
KEY_KP_6            = 326;      // Key: Keypad 6
KEY_KP_7            = 327;      // Key: Keypad 7
KEY_KP_8            = 328;      // Key: Keypad 8
KEY_KP_9            = 329;      // Key: Keypad 9
KEY_KP_DECIMAL      = 330;      // Key: Keypad .
KEY_KP_DIVIDE       = 331;      // Key: Keypad /
KEY_KP_MULTIPLY     = 332;      // Key: Keypad *
KEY_KP_SUBTRACT     = 333;      // Key: Keypad -
KEY_KP_ADD          = 334;      // Key: Keypad +
KEY_KP_ENTER        = 335;      // Key: Keypad Enter
KEY_KP_EQUAL        = 336;      // Key: Keypad =
// Android key buttons
KEY_BACK            = 4;        // Key: Android back button
KEY_MENU            = 5;        // Key: Android menu button
KEY_VOLUME_UP       = 24;       // Key: Android volume up button
KEY_VOLUME_DOWN     = 25;       // Key: Android volume down button

// Mouse buttons
MOUSE_BUTTON_LEFT    = 0;       // Mouse button left
MOUSE_BUTTON_RIGHT   = 1;       // Mouse button right
MOUSE_BUTTON_MIDDLE  = 2;       // Mouse button middle (pressed wheel)
MOUSE_BUTTON_SIDE    = 3;       // Mouse button side (advanced mouse device)
MOUSE_BUTTON_EXTRA   = 4;       // Mouse button extra (advanced mouse device)
MOUSE_BUTTON_FORWARD = 5;       // Mouse button forward (advanced mouse device)
MOUSE_BUTTON_BACK    = 6;       // Mouse button back (advanced mouse device)

// Add backwards compatibility support for deprecated names
MOUSE_LEFT_BUTTON   =   MOUSE_BUTTON_LEFT;
MOUSE_RIGHT_BUTTON  =  MOUSE_BUTTON_RIGHT;
MOUSE_MIDDLE_BUTTON = MOUSE_BUTTON_MIDDLE;

// Mouse cursor
MOUSE_CURSOR_DEFAULT       = 0;     // Default pointer shape
MOUSE_CURSOR_ARROW         = 1;     // Arrow shape
MOUSE_CURSOR_IBEAM         = 2;     // Text writing cursor shape
MOUSE_CURSOR_CROSSHAIR     = 3;     // Cross shape
MOUSE_CURSOR_POINTING_HAND = 4;     // Pointing hand cursor
MOUSE_CURSOR_RESIZE_EW     = 5;     // Horizontal resize/move arrow shape
MOUSE_CURSOR_RESIZE_NS     = 6;     // Vertical resize/move arrow shape
MOUSE_CURSOR_RESIZE_NWSE   = 7;     // Top-left to bottom-right diagonal resize/move arrow shape
MOUSE_CURSOR_RESIZE_NESW   = 8;     // The top-right to bottom-left diagonal resize/move arrow shape
MOUSE_CURSOR_RESIZE_ALL    = 9;     // The omnidirectional resize/move cursor shape
MOUSE_CURSOR_NOT_ALLOWED   = 10;    // The operation-not-allowed shape

// Gamepad buttons
GAMEPAD_BUTTON_UNKNOWN              = 0;     // Unknown button, just for error checking
GAMEPAD_BUTTON_LEFT_FACE_UP         = 1;     // Gamepad left DPAD up button
GAMEPAD_BUTTON_LEFT_FACE_RIGHT      = 2;     // Gamepad left DPAD right button
GAMEPAD_BUTTON_LEFT_FACE_DOWN       = 3;     // Gamepad left DPAD down button
GAMEPAD_BUTTON_LEFT_FACE_LEFT       = 4;     // Gamepad left DPAD left button
GAMEPAD_BUTTON_RIGHT_FACE_UP        = 5;     // Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
GAMEPAD_BUTTON_RIGHT_FACE_RIGHT     = 6;     // Gamepad right button right (i.e. PS3: Circle, Xbox: B)
GAMEPAD_BUTTON_RIGHT_FACE_DOWN      = 7;     // Gamepad right button down (i.e. PS3: Cross, Xbox: A)
GAMEPAD_BUTTON_RIGHT_FACE_LEFT      = 8;     // Gamepad right button left (i.e. PS3: Square, Xbox: X)
GAMEPAD_BUTTON_LEFT_TRIGGER_1       = 9;     // Gamepad top/back trigger left (first), it could be a trailing button
GAMEPAD_BUTTON_LEFT_TRIGGER_2       = 10;    // Gamepad top/back trigger left (second), it could be a trailing button
GAMEPAD_BUTTON_RIGHT_TRIGGER_1      = 12;    // Gamepad top/back trigger right (first), it could be a trailing button
GAMEPAD_BUTTON_RIGHT_TRIGGER_2      = 13;    // Gamepad top/back trigger right (second), it could be a trailing button
GAMEPAD_BUTTON_MIDDLE_LEFT          = 14;    // Gamepad center buttons, left one (i.e. PS3: Select)
GAMEPAD_BUTTON_MIDDLE               = 15;    // Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
GAMEPAD_BUTTON_MIDDLE_RIGHT         = 16;    // Gamepad center buttons, right one (i.e. PS3: Start)
GAMEPAD_BUTTON_LEFT_THUMB           = 17;    // Gamepad joystick pressed button left
GAMEPAD_BUTTON_RIGHT_THUMB          = 18;    // Gamepad joystick pressed button right

// Gamepad axes
GAMEPAD_AXIS_LEFT_X        = 0;     // Gamepad left stick X axis
GAMEPAD_AXIS_LEFT_Y        = 1;     // Gamepad left stick Y axis
GAMEPAD_AXIS_RIGHT_X       = 2;     // Gamepad right stick X axis
GAMEPAD_AXIS_RIGHT_Y       = 3;     // Gamepad right stick Y axis
GAMEPAD_AXIS_LEFT_TRIGGER  = 4;     // Gamepad back trigger left, pressure level: [1..-1]
GAMEPAD_AXIS_RIGHT_TRIGGER = 5;     // Gamepad back trigger right, pressure level: [1..-1]

// Material map indexes
MATERIAL_MAP_ALBEDO      = 0;      // Albedo material (same as: MATERIAL_MAP_DIFFUSE)
MATERIAL_MAP_METALNESS   = 1;      // Metalness material (same as: MATERIAL_MAP_SPECULAR)
MATERIAL_MAP_NORMAL      = 2;      // Normal material
MATERIAL_MAP_ROUGHNESS   = 3;      // Roughness material
MATERIAL_MAP_OCCLUSION   = 4;      // Ambient occlusion material
MATERIAL_MAP_EMISSION    = 5;      // Emission material
MATERIAL_MAP_HEIGHT      = 6;      // Heightmap material
MATERIAL_MAP_CUBEMAP     = 7;      // Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
MATERIAL_MAP_IRRADIANCE  = 8;      // Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
MATERIAL_MAP_PREFILTER   = 9;      // Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
MATERIAL_MAP_BRDF        = 10;      // Brdf material

MATERIAL_MAP_DIFFUSE     = MATERIAL_MAP_ALBEDO;
MATERIAL_MAP_SPECULAR    = MATERIAL_MAP_METALNESS;

// Shader location index
SHADER_LOC_VERTEX_POSITION    = 0;      // Shader location: vertex attribute: position
SHADER_LOC_VERTEX_TEXCOORD01  = 1;      // Shader location: vertex attribute: texcoord01
SHADER_LOC_VERTEX_TEXCOORD02  = 2;      // Shader location: vertex attribute: texcoord02
SHADER_LOC_VERTEX_NORMAL      = 3;      // Shader location: vertex attribute: normal
SHADER_LOC_VERTEX_TANGENT     = 4;      // Shader location: vertex attribute: tangent
SHADER_LOC_VERTEX_COLOR       = 5;      // Shader location: vertex attribute: color
SHADER_LOC_MATRIX_MVP         = 6;      // Shader location: matrix uniform: model-view-projection
SHADER_LOC_MATRIX_VIEW        = 7;      // Shader location: matrix uniform: view (camera transform)
SHADER_LOC_MATRIX_PROJECTION  = 8;      // Shader location: matrix uniform: projection
SHADER_LOC_MATRIX_MODEL       = 9;      // Shader location: matrix uniform: model (transform)
SHADER_LOC_MATRIX_NORMAL      = 10;      // Shader location: matrix uniform: normal
SHADER_LOC_VECTOR_VIEW        = 11;      // Shader location: vector uniform: view
SHADER_LOC_COLOR_DIFFUSE      = 12;      // Shader location: vector uniform: diffuse color
SHADER_LOC_COLOR_SPECULAR     = 13;      // Shader location: vector uniform: specular color
SHADER_LOC_COLOR_AMBIENT      = 14;      // Shader location: vector uniform: ambient color
SHADER_LOC_MAP_ALBEDO         = 15;      // Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
SHADER_LOC_MAP_METALNESS      = 16;      // Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
SHADER_LOC_MAP_NORMAL         = 17;      // Shader location: sampler2d texture: normal
SHADER_LOC_MAP_ROUGHNESS      = 18;      // Shader location: sampler2d texture: roughness
SHADER_LOC_MAP_OCCLUSION      = 19;      // Shader location: sampler2d texture: occlusion
SHADER_LOC_MAP_EMISSION       = 20;      // Shader location: sampler2d texture: emission
SHADER_LOC_MAP_HEIGHT         = 21;      // Shader location: sampler2d texture: height
SHADER_LOC_MAP_CUBEMAP        = 22;      // Shader location: samplerCube texture: cubemap
SHADER_LOC_MAP_IRRADIANCE     = 23;      // Shader location: samplerCube texture: irradiance
SHADER_LOC_MAP_PREFILTER      = 24;      // Shader location: samplerCube texture: prefilter
SHADER_LOC_MAP_BRDF           = 25;      // Shader location: sampler2d texture: brdf
SHADER_LOC_VERTEX_BONEIDS     = 26;      // Shader location: vertex attribute: boneIds
SHADER_LOC_VERTEX_BONEWEIGHTS = 27;      // Shader location: vertex attribute: boneWeights
SHADER_LOC_BONE_MATRICES      = 28;      // Shader location: array of matrices uniform: boneMatrices
SHADER_LOC_VERTEX_INSTANCE_TX = 29;      // Shader location: vertex attribute: instanceTransform

SHADER_LOC_MAP_DIFFUSE   =   SHADER_LOC_MAP_ALBEDO;
SHADER_LOC_MAP_SPECULAR  =   SHADER_LOC_MAP_METALNESS;

// Shader uniform data types
SHADER_UNIFORM_FLOAT      = 0;     // Shader uniform type: float
SHADER_UNIFORM_VEC2       = 1;     // Shader uniform type: vec2 (2 float)
SHADER_UNIFORM_VEC3       = 2;     // Shader uniform type: vec3 (3 float)
SHADER_UNIFORM_VEC4       = 3;     // Shader uniform type: vec4 (4 float)
SHADER_UNIFORM_INT        = 4;     // Shader uniform type: int
SHADER_UNIFORM_IVEC2      = 5;     // Shader uniform type: ivec2 (2 int)
SHADER_UNIFORM_IVEC3      = 6;     // Shader uniform type: ivec3 (3 int)
SHADER_UNIFORM_IVEC4      = 7;     // Shader uniform type: ivec4 (4 int)
SHADER_UNIFORM_UINT       = 8;     // Shader uniform type: unsigned int
SHADER_UNIFORM_UIVEC2     = 9;     // Shader uniform type: uivec2 (2 unsigned int)
SHADER_UNIFORM_UIVEC3     = 10;    // Shader uniform type: uivec3 (3 unsigned int)
SHADER_UNIFORM_UIVEC4     = 11;    // Shader uniform type: uivec4 (4 unsigned int)
SHADER_UNIFORM_SAMPLER2D  = 12;    // Shader uniform type: sampler2d

// Shader attribute data types
SHADER_ATTRIB_FLOAT             = 0;   // Shader attribute type: float
SHADER_ATTRIB_VEC2              = 1;   // Shader attribute type: vec2 (2 floats)
SHADER_ATTRIB_VEC3              = 2;   // Shader attribute type: vec3 (3 floats)
SHADER_ATTRIB_VEC4              = 3;   // Shader attribute type: vec4 (4 floats)

// Pixel formats (support depends on OpenGL version and platform)
PIXELFORMAT_UNCOMPRESSED_GRAYSCALE     = 1;   // 8 bit per pixel (no alpha)
PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA    = 2;   // 8*2 bpp (2 channels)
PIXELFORMAT_UNCOMPRESSED_R5G6B5        = 3;   // 16 bpp
PIXELFORMAT_UNCOMPRESSED_R8G8B8        = 4;   // 24 bpp
PIXELFORMAT_UNCOMPRESSED_R5G5B5A1      = 5;   // 16 bpp (1 bit alpha)
PIXELFORMAT_UNCOMPRESSED_R4G4B4A4      = 6;   // 16 bpp (4 bit alpha)
PIXELFORMAT_UNCOMPRESSED_R8G8B8A8      = 7;   // 32 bpp
PIXELFORMAT_UNCOMPRESSED_R32           = 8;   // 32 bpp (1 channel - float)
PIXELFORMAT_UNCOMPRESSED_R32G32B32     = 9;   // 32*3 bpp (3 channels - float)
PIXELFORMAT_UNCOMPRESSED_R32G32B32A32  = 10;  // 32*4 bpp (4 channels - float)
PIXELFORMAT_UNCOMPRESSED_R16           = 11;  // 16 bpp (1 channel - half float)
PIXELFORMAT_UNCOMPRESSED_R16G16B16     = 12;  // 16*3 bpp (3 channels - half float)
PIXELFORMAT_UNCOMPRESSED_R16G16B16A16  = 13;  // 16*4 bpp (4 channels - half float)
PIXELFORMAT_COMPRESSED_DXT1_RGB        = 14;  // 4 bpp (no alpha)
PIXELFORMAT_COMPRESSED_DXT1_RGBA       = 15;  // 4 bpp (1 bit alpha)
PIXELFORMAT_COMPRESSED_DXT3_RGBA       = 16;  // 8 bpp
PIXELFORMAT_COMPRESSED_DXT5_RGBA       = 17;  // 8 bpp
PIXELFORMAT_COMPRESSED_ETC1_RGB        = 18;  // 4 bpp
PIXELFORMAT_COMPRESSED_ETC2_RGB        = 19;  // 4 bpp
PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA   = 20;  // 8 bpp
PIXELFORMAT_COMPRESSED_PVRT_RGB        = 21;  // 4 bpp
PIXELFORMAT_COMPRESSED_PVRT_RGBA       = 22;  // 4 bpp
PIXELFORMAT_COMPRESSED_ASTC_4X4_RGBA   = 23;  // 8 bpp
PIXELFORMAT_COMPRESSED_ASTC_8X8_RGBA   = 24;  // 2 bpp

// Texture parameters: filter mode
TEXTURE_FILTER_POINT               = 0;   // No filter, just pixel approximation
TEXTURE_FILTER_BILINEAR            = 1;   // Linear filtering
TEXTURE_FILTER_TRILINEAR           = 2;   // Trilinear filtering (linear with mipmaps)
TEXTURE_FILTER_ANISOTROPIC_4X      = 3;   // Anisotropic filtering 4x
TEXTURE_FILTER_ANISOTROPIC_8X      = 4;   // Anisotropic filtering 8x
TEXTURE_FILTER_ANISOTROPIC_16X     = 5;   // Anisotropic filtering 16x

// Texture parameters: wrap mode
TEXTURE_WRAP_REPEAT                = 0;   // Repeats texture in tiled mode
TEXTURE_WRAP_CLAMP                 = 1;   // Clamps texture to edge pixel in tiled mode
TEXTURE_WRAP_MIRROR_REPEAT         = 2;   // Mirrors and repeats the texture in tiled mode
TEXTURE_WRAP_MIRROR_CLAMP          = 3;   // Mirrors and clamps texture to border in tiled mode

// Cubemap layouts
CUBEMAP_LAYOUT_AUTO_DETECT         = 0;   // Automatically detect layout type
CUBEMAP_LAYOUT_LINE_VERTICAL       = 1;   // Vertical line layout
CUBEMAP_LAYOUT_LINE_HORIZONTAL     = 2;   // Horizontal line layout
CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR = 3;   // 3x4 cross layout
CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE = 4;   // 4x3 cross layout

// Font type, defines generation method
FONT_DEFAULT          = 0;   // Default font generation, anti-aliased
FONT_BITMAP           = 1;   // Bitmap font generation, no anti-aliasing
FONT_SDF              = 2;   // SDF font generation, requires external shader

// Color blending modes (pre-defined)
BLEND_ALPHA                 = 0;   // Blend textures considering alpha (default)
BLEND_ADDITIVE              = 1;   // Blend textures adding colors
BLEND_MULTIPLIED            = 2;   // Blend textures multiplying colors
BLEND_ADD_COLORS            = 3;   // Blend textures adding colors (alternative)
BLEND_SUBTRACT_COLORS       = 4;   // Blend textures subtracting colors (alternative)
BLEND_ALPHA_PREMULTIPLY     = 5;   // Blend premultiplied textures considering alpha
BLEND_CUSTOM                = 6;   // Blend textures using custom src/dst factors
BLEND_CUSTOM_SEPARATE       = 7;   // Blend textures with separate rgb/alpha factors

// Gesture flags (bitwise)
GESTURE_NONE            = 0;     // No gesture
GESTURE_TAP             = 1;     // Tap gesture
GESTURE_DOUBLETAP       = 2;     // Double tap gesture
GESTURE_HOLD            = 4;     // Hold gesture
GESTURE_DRAG            = 8;     // Drag gesture
GESTURE_SWIPE_RIGHT     = 16;    // Swipe right gesture
GESTURE_SWIPE_LEFT      = 32;    // Swipe left gesture
GESTURE_SWIPE_UP        = 64;    // Swipe up gesture
GESTURE_SWIPE_DOWN      = 128;   // Swipe down gesture
GESTURE_PINCH_IN        = 256;   // Pinch in gesture
GESTURE_PINCH_OUT       = 512;   // Pinch out gesture

// Camera system modes
CAMERA_CUSTOM          = 0;   // Custom, controlled by user (UpdateCamera() does nothing)
CAMERA_FREE            = 1;   // Free mode
CAMERA_ORBITAL         = 2;   // Orbital mode, around target with zoom
CAMERA_FIRST_PERSON    = 3;   // First person mode
CAMERA_THIRD_PERSON    = 4;   // Third person mode

// Camera projection
CAMERA_PERSPECTIVE      = 0;   // Perspective projection
CAMERA_ORTHOGRAPHIC     = 1;   // Orthographic projection

// N-patch layouts
NPATCH_NINE_PATCH             = 0;  // 3x3 tiles
NPATCH_THREE_PATCH_VERTICAL   = 1;  // 1x3 tiles
NPATCH_THREE_PATCH_HORIZONTAL = 2;  // 3x1 tiles